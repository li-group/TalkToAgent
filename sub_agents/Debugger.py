import os
import ast
import numpy as np
from dotenv import load_dotenv
from openai import OpenAI

from prompts import get_system_description, get_prompts
from utils import py2str, str2py, py2func

from params import running_params, env_params

running_params = running_params()
env, env_params = env_params(running_params['system'])

# LLM settings
load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)
MODEL = 'gpt-4.1'


class Debugger:
    def __init__(self):
        self.history = []

    def debug(self, orig_code, error_message):
        """
        Analyze the error based on the code generated by Coder agent and return suggestions for modification.
        Returns:
            orig_code (string): Original code
            error_message (string): Error message
        """

        evaluator_prompt = """
        You are a coding expert that provides proper guidance to the coder agent,
        to refine the generated code properly and solve the error issue. 
        
        For accurate debugging, here are some descriptions of the control system:
        {system_description}
        
        Also, environment parameters used in process control:
        {env_params}
    
        You will get a great reward if you correctly guide the coder agent to refine accurately!
        """

        messages = [
            {"role": "system", "content": evaluator_prompt.format(
                system_description=get_system_description(running_params['system']),
                env_params=vars(env)
            )},
            {"role": "user", "content": f"""
            What should the coder agent do in order to solve this error message?
            
            Original code:
            {orig_code}
            
            Error message:
            {error_message}
            """
             }
        ]

        response = client.chat.completions.create(
            model=MODEL,
            messages=messages,
        )

        guidance = response.choices[0].message.content

        return guidance

def check_reward_consistency(original_fn, decomposed_fn, x, u, con):
    r_scalar = original_fn(x, u, con)
    r_components = decomposed_fn(x, u, con)
    return np.isclose(r_scalar, sum(r_components), atol=1e-5)



